{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar qs = require('querystring');\nvar parse = require('url').parse;\nvar base64id = require('base64id');\nvar transports = require('./transports');\nvar EventEmitter = require('events').EventEmitter;\nvar Socket = require('./socket');\nvar util = require('util');\nvar debug = require('debug')('engine');\nvar cookieMod = require('cookie');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Server;\n\n/**\n * Server constructor.\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Server(opts) {\n  if (!(this instanceof Server)) {\n    return new Server(opts);\n  }\n  this.clients = {};\n  this.clientsCount = 0;\n  opts = opts || {};\n  this.wsEngine = opts.wsEngine || process.env.EIO_WS_ENGINE;\n  this.pingTimeout = opts.pingTimeout || 60000;\n  this.pingInterval = opts.pingInterval || 25000;\n  this.upgradeTimeout = opts.upgradeTimeout || 10000;\n  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;\n  this.transports = opts.transports || Object.keys(transports);\n  this.allowUpgrades = false !== opts.allowUpgrades;\n  this.allowRequest = opts.allowRequest;\n  this.cookie = false !== opts.cookie ? opts.cookie || 'io' : false;\n  this.cookiePath = false !== opts.cookiePath ? opts.cookiePath || '/' : false;\n  this.cookieHttpOnly = false !== opts.cookieHttpOnly;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || true : false;\n  this.httpCompression = false !== opts.httpCompression ? opts.httpCompression || {} : false;\n  var self = this;\n\n  // initialize compression options\n  ['perMessageDeflate', 'httpCompression'].forEach(function (type) {\n    var compression = self[type];\n    if (true === compression) self[type] = compression = {};\n    if (compression && null == compression.threshold) {\n      compression.threshold = 1024;\n    }\n  });\n\n  // initialize websocket server\n  if (~this.transports.indexOf('websocket')) {\n    // keep require('ws') as separate expression for packers (browserify, etc)\n    var WebSocketServer = (this.wsEngine ? require(this.wsEngine) : require('ws')).Server;\n    this.ws = new WebSocketServer({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.perMessageDeflate,\n      maxPayload: this.maxHttpBufferSize\n    });\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3\n};\nServer.errorMessages = {\n  0: 'Transport unknown',\n  1: 'Session ID unknown',\n  2: 'Bad handshake method',\n  3: 'Bad request'\n};\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Server, EventEmitter);\n\n/**\n * Hash of open clients.\n *\n * @api public\n */\n\nServer.prototype.clients;\n\n/**\n * Returns a list of available transports for upgrade given a certain transport.\n *\n * @return {Array}\n * @api public\n */\n\nServer.prototype.upgrades = function (transport) {\n  if (!this.allowUpgrades) return [];\n  return transports[transport].upgradesTo || [];\n};\n\n/**\n * Verifies a request.\n *\n * @param {http.IncomingMessage}\n * @return {Boolean} whether the request is valid\n * @api private\n */\n\nServer.prototype.verify = function (req, upgrade, fn) {\n  // transport check\n  var transport = req._query.transport;\n  if (!~this.transports.indexOf(transport)) {\n    debug('unknown transport \"%s\"', transport);\n    return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n  }\n\n  // sid check\n  var sid = req._query.sid;\n  if (sid) {\n    if (!this.clients.hasOwnProperty(sid)) {\n      return fn(Server.errors.UNKNOWN_SID, false);\n    }\n    if (!upgrade && this.clients[sid].transport.name !== transport) {\n      debug('bad request: unexpected transport without upgrade');\n      return fn(Server.errors.BAD_REQUEST, false);\n    }\n  } else {\n    // handshake is GET only\n    if ('GET' !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n    if (!this.allowRequest) return fn(null, true);\n    return this.allowRequest(req, fn);\n  }\n  fn(null, true);\n};\n\n/**\n * Prepares a request by processing the query string.\n *\n * @api private\n */\n\nServer.prototype.prepare = function (req) {\n  // try to leverage pre-existing `req._query` (e.g: from connect)\n  if (!req._query) {\n    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};\n  }\n};\n\n/**\n * Closes all clients.\n *\n * @api public\n */\n\nServer.prototype.close = function () {\n  debug('closing all open clients');\n  for (var i in this.clients) {\n    if (this.clients.hasOwnProperty(i)) {\n      this.clients[i].close(true);\n    }\n  }\n  if (this.ws) {\n    debug('closing webSocketServer');\n    this.ws.close();\n    // don't delete this.ws because it can be used again if the http server starts listening again\n  }\n  return this;\n};\n\n/**\n * Handles an Engine.IO HTTP request.\n *\n * @param {http.IncomingMessage} request\n * @param {http.ServerResponse|http.OutgoingMessage} response\n * @api public\n */\n\nServer.prototype.handleRequest = function (req, res) {\n  debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n  this.prepare(req);\n  req.res = res;\n  var self = this;\n  this.verify(req, false, function (err, success) {\n    if (!success) {\n      sendErrorMessage(req, res, err);\n      return;\n    }\n    if (req._query.sid) {\n      debug('setting new request for existing client');\n      self.clients[req._query.sid].transport.onRequest(req);\n    } else {\n      self.handshake(req._query.transport, req);\n    }\n  });\n};\n\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\nfunction sendErrorMessage(req, res, code) {\n  var headers = {\n    'Content-Type': 'application/json'\n  };\n  if (req.headers.origin) {\n    headers['Access-Control-Allow-Credentials'] = 'true';\n    headers['Access-Control-Allow-Origin'] = req.headers.origin;\n  } else {\n    headers['Access-Control-Allow-Origin'] = '*';\n  }\n  res.writeHead(400, headers);\n  res.end(JSON.stringify({\n    code: code,\n    message: Server.errorMessages[code]\n  }));\n}\n\n/**\n * generate a socket id.\n * Overwrite this method to generate your custom socket id\n *\n * @param {Object} request object\n * @api public\n */\n\nServer.prototype.generateId = function (req) {\n  return base64id.generateId();\n};\n\n/**\n * Handshakes a new client.\n *\n * @param {String} transport name\n * @param {Object} request object\n * @api private\n */\n\nServer.prototype.handshake = function (transportName, req) {\n  var id = this.generateId(req);\n  debug('handshaking client \"%s\"', id);\n  try {\n    var transport = new transports[transportName](req);\n    if ('polling' === transportName) {\n      transport.maxHttpBufferSize = this.maxHttpBufferSize;\n      transport.httpCompression = this.httpCompression;\n    } else if ('websocket' === transportName) {\n      transport.perMessageDeflate = this.perMessageDeflate;\n    }\n    if (req._query && req._query.b64) {\n      transport.supportsBinary = false;\n    } else {\n      transport.supportsBinary = true;\n    }\n  } catch (e) {\n    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n    return;\n  }\n  var socket = new Socket(id, this, transport, req);\n  var self = this;\n  if (false !== this.cookie) {\n    transport.on('headers', function (headers) {\n      headers['Set-Cookie'] = cookieMod.serialize(self.cookie, id, {\n        path: self.cookiePath,\n        httpOnly: self.cookiePath ? self.cookieHttpOnly : false\n      });\n    });\n  }\n  transport.onRequest(req);\n  this.clients[id] = socket;\n  this.clientsCount++;\n  socket.once('close', function () {\n    delete self.clients[id];\n    self.clientsCount--;\n  });\n  this.emit('connection', socket);\n};\n\n/**\n * Handles an Engine.IO HTTP Upgrade.\n *\n * @api public\n */\n\nServer.prototype.handleUpgrade = function (req, socket, upgradeHead) {\n  this.prepare(req);\n  var self = this;\n  this.verify(req, true, function (err, success) {\n    if (!success) {\n      abortConnection(socket, err);\n      return;\n    }\n    var head = new Buffer(upgradeHead.length);\n    upgradeHead.copy(head);\n    upgradeHead = null;\n\n    // delegate to ws\n    self.ws.handleUpgrade(req, socket, head, function (conn) {\n      self.onWebSocket(req, conn);\n    });\n  });\n};\n\n/**\n * Called upon a ws.io connection.\n *\n * @param {ws.Socket} websocket\n * @api private\n */\n\nServer.prototype.onWebSocket = function (req, socket) {\n  socket.on('error', onUpgradeError);\n  if (!transports[req._query.transport].prototype.handlesUpgrades) {\n    debug('transport doesnt handle upgraded requests');\n    socket.close();\n    return;\n  }\n\n  // get client id\n  var id = req._query.sid;\n\n  // keep a reference to the ws.Socket\n  req.websocket = socket;\n  if (id) {\n    var client = this.clients[id];\n    if (!client) {\n      debug('upgrade attempt for closed client');\n      socket.close();\n    } else if (client.upgrading) {\n      debug('transport has already been trying to upgrade');\n      socket.close();\n    } else if (client.upgraded) {\n      debug('transport had already been upgraded');\n      socket.close();\n    } else {\n      debug('upgrading existing transport');\n\n      // transport error handling takes over\n      socket.removeListener('error', onUpgradeError);\n      var transport = new transports[req._query.transport](req);\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n      transport.perMessageDeflate = this.perMessageDeflate;\n      client.maybeUpgrade(transport);\n    }\n  } else {\n    // transport error handling takes over\n    socket.removeListener('error', onUpgradeError);\n    this.handshake(req._query.transport, req);\n  }\n  function onUpgradeError() {\n    debug('websocket error before upgrade');\n    // socket.close() not needed\n  }\n};\n\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @api public\n */\n\nServer.prototype.attach = function (server, options) {\n  var self = this;\n  options = options || {};\n  var path = (options.path || '/engine.io').replace(/\\/$/, '');\n  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n  // normalize path\n  path += '/';\n  function check(req) {\n    return path === req.url.substr(0, path.length);\n  }\n\n  // cache and clean up listeners\n  var listeners = server.listeners('request').slice(0);\n  server.removeAllListeners('request');\n  server.on('close', self.close.bind(self));\n\n  // add request handler\n  server.on('request', function (req, res) {\n    if (check(req)) {\n      debug('intercepting request for path \"%s\"', path);\n      self.handleRequest(req, res);\n    } else {\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].call(server, req, res);\n      }\n    }\n  });\n  if (~self.transports.indexOf('websocket')) {\n    server.on('upgrade', function (req, socket, head) {\n      if (check(req)) {\n        self.handleUpgrade(req, socket, head);\n      } else if (false !== options.destroyUpgrade) {\n        // default node behavior is to disconnect when no handlers\n        // but by adding a handler, we prevent that\n        // and if no eio thing handles the upgrade\n        // then the socket needs to die!\n        setTimeout(function () {\n          if (socket.writable && socket.bytesWritten <= 0) {\n            return socket.end();\n          }\n        }, destroyUpgradeTimeout);\n      }\n    });\n  }\n};\n\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\nfunction abortConnection(socket, code) {\n  if (socket.writable) {\n    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : code || '';\n    var length = Buffer.byteLength(message);\n    socket.write('HTTP/1.1 400 Bad Request\\r\\n' + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: ' + length + '\\r\\n' + '\\r\\n' + message);\n  }\n  socket.destroy();\n}","map":{"version":3,"names":["qs","require","parse","base64id","transports","EventEmitter","Socket","util","debug","cookieMod","module","exports","Server","opts","clients","clientsCount","wsEngine","process","env","EIO_WS_ENGINE","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","Object","keys","allowUpgrades","allowRequest","cookie","cookiePath","cookieHttpOnly","perMessageDeflate","httpCompression","self","forEach","type","compression","threshold","indexOf","WebSocketServer","ws","noServer","clientTracking","maxPayload","errors","UNKNOWN_TRANSPORT","UNKNOWN_SID","BAD_HANDSHAKE_METHOD","BAD_REQUEST","errorMessages","inherits","prototype","upgrades","transport","upgradesTo","verify","req","upgrade","fn","_query","sid","hasOwnProperty","name","method","prepare","url","query","close","i","handleRequest","res","err","success","sendErrorMessage","onRequest","handshake","code","headers","origin","writeHead","end","JSON","stringify","message","generateId","transportName","id","b64","supportsBinary","e","socket","on","serialize","path","httpOnly","once","emit","handleUpgrade","upgradeHead","abortConnection","head","Buffer","length","copy","conn","onWebSocket","onUpgradeError","handlesUpgrades","websocket","client","upgrading","upgraded","removeListener","maybeUpgrade","attach","server","options","replace","destroyUpgradeTimeout","check","substr","listeners","slice","removeAllListeners","bind","l","call","destroyUpgrade","setTimeout","writable","bytesWritten","byteLength","write","destroy"],"sources":["C:/Users/walle/Documents/lummelundalogin/lummelundalogin/node_modules/engine.io/lib/server.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar qs = require('querystring');\nvar parse = require('url').parse;\nvar base64id = require('base64id');\nvar transports = require('./transports');\nvar EventEmitter = require('events').EventEmitter;\nvar Socket = require('./socket');\nvar util = require('util');\nvar debug = require('debug')('engine');\nvar cookieMod = require('cookie');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Server;\n\n/**\n * Server constructor.\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Server (opts) {\n  if (!(this instanceof Server)) {\n    return new Server(opts);\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n\n  opts = opts || {};\n\n  this.wsEngine = opts.wsEngine || process.env.EIO_WS_ENGINE;\n  this.pingTimeout = opts.pingTimeout || 60000;\n  this.pingInterval = opts.pingInterval || 25000;\n  this.upgradeTimeout = opts.upgradeTimeout || 10000;\n  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;\n  this.transports = opts.transports || Object.keys(transports);\n  this.allowUpgrades = false !== opts.allowUpgrades;\n  this.allowRequest = opts.allowRequest;\n  this.cookie = false !== opts.cookie ? (opts.cookie || 'io') : false;\n  this.cookiePath = false !== opts.cookiePath ? (opts.cookiePath || '/') : false;\n  this.cookieHttpOnly = false !== opts.cookieHttpOnly;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || true) : false;\n  this.httpCompression = false !== opts.httpCompression ? (opts.httpCompression || {}) : false;\n\n  var self = this;\n\n  // initialize compression options\n  ['perMessageDeflate', 'httpCompression'].forEach(function (type) {\n    var compression = self[type];\n    if (true === compression) self[type] = compression = {};\n    if (compression && null == compression.threshold) {\n      compression.threshold = 1024;\n    }\n  });\n\n  // initialize websocket server\n  if (~this.transports.indexOf('websocket')) {\n    // keep require('ws') as separate expression for packers (browserify, etc)\n    var WebSocketServer = (this.wsEngine ? require(this.wsEngine) : require('ws')).Server;\n    this.ws = new WebSocketServer({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.perMessageDeflate,\n      maxPayload: this.maxHttpBufferSize\n    });\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3\n};\n\nServer.errorMessages = {\n  0: 'Transport unknown',\n  1: 'Session ID unknown',\n  2: 'Bad handshake method',\n  3: 'Bad request'\n};\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Server, EventEmitter);\n\n/**\n * Hash of open clients.\n *\n * @api public\n */\n\nServer.prototype.clients;\n\n/**\n * Returns a list of available transports for upgrade given a certain transport.\n *\n * @return {Array}\n * @api public\n */\n\nServer.prototype.upgrades = function (transport) {\n  if (!this.allowUpgrades) return [];\n  return transports[transport].upgradesTo || [];\n};\n\n/**\n * Verifies a request.\n *\n * @param {http.IncomingMessage}\n * @return {Boolean} whether the request is valid\n * @api private\n */\n\nServer.prototype.verify = function (req, upgrade, fn) {\n  // transport check\n  var transport = req._query.transport;\n  if (!~this.transports.indexOf(transport)) {\n    debug('unknown transport \"%s\"', transport);\n    return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n  }\n\n  // sid check\n  var sid = req._query.sid;\n  if (sid) {\n    if (!this.clients.hasOwnProperty(sid)) {\n      return fn(Server.errors.UNKNOWN_SID, false);\n    }\n    if (!upgrade && this.clients[sid].transport.name !== transport) {\n      debug('bad request: unexpected transport without upgrade');\n      return fn(Server.errors.BAD_REQUEST, false);\n    }\n  } else {\n    // handshake is GET only\n    if ('GET' !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n    if (!this.allowRequest) return fn(null, true);\n    return this.allowRequest(req, fn);\n  }\n\n  fn(null, true);\n};\n\n/**\n * Prepares a request by processing the query string.\n *\n * @api private\n */\n\nServer.prototype.prepare = function (req) {\n  // try to leverage pre-existing `req._query` (e.g: from connect)\n  if (!req._query) {\n    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};\n  }\n};\n\n/**\n * Closes all clients.\n *\n * @api public\n */\n\nServer.prototype.close = function () {\n  debug('closing all open clients');\n  for (var i in this.clients) {\n    if (this.clients.hasOwnProperty(i)) {\n      this.clients[i].close(true);\n    }\n  }\n  if (this.ws) {\n    debug('closing webSocketServer');\n    this.ws.close();\n    // don't delete this.ws because it can be used again if the http server starts listening again\n  }\n  return this;\n};\n\n/**\n * Handles an Engine.IO HTTP request.\n *\n * @param {http.IncomingMessage} request\n * @param {http.ServerResponse|http.OutgoingMessage} response\n * @api public\n */\n\nServer.prototype.handleRequest = function (req, res) {\n  debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n  this.prepare(req);\n  req.res = res;\n\n  var self = this;\n  this.verify(req, false, function (err, success) {\n    if (!success) {\n      sendErrorMessage(req, res, err);\n      return;\n    }\n\n    if (req._query.sid) {\n      debug('setting new request for existing client');\n      self.clients[req._query.sid].transport.onRequest(req);\n    } else {\n      self.handshake(req._query.transport, req);\n    }\n  });\n};\n\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\nfunction sendErrorMessage (req, res, code) {\n  var headers = { 'Content-Type': 'application/json' };\n\n  if (req.headers.origin) {\n    headers['Access-Control-Allow-Credentials'] = 'true';\n    headers['Access-Control-Allow-Origin'] = req.headers.origin;\n  } else {\n    headers['Access-Control-Allow-Origin'] = '*';\n  }\n  res.writeHead(400, headers);\n  res.end(JSON.stringify({\n    code: code,\n    message: Server.errorMessages[code]\n  }));\n}\n\n/**\n * generate a socket id.\n * Overwrite this method to generate your custom socket id\n *\n * @param {Object} request object\n * @api public\n */\n\nServer.prototype.generateId = function (req) {\n  return base64id.generateId();\n};\n\n/**\n * Handshakes a new client.\n *\n * @param {String} transport name\n * @param {Object} request object\n * @api private\n */\n\nServer.prototype.handshake = function (transportName, req) {\n  var id = this.generateId(req);\n\n  debug('handshaking client \"%s\"', id);\n\n  try {\n    var transport = new transports[transportName](req);\n    if ('polling' === transportName) {\n      transport.maxHttpBufferSize = this.maxHttpBufferSize;\n      transport.httpCompression = this.httpCompression;\n    } else if ('websocket' === transportName) {\n      transport.perMessageDeflate = this.perMessageDeflate;\n    }\n\n    if (req._query && req._query.b64) {\n      transport.supportsBinary = false;\n    } else {\n      transport.supportsBinary = true;\n    }\n  } catch (e) {\n    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n    return;\n  }\n  var socket = new Socket(id, this, transport, req);\n  var self = this;\n\n  if (false !== this.cookie) {\n    transport.on('headers', function (headers) {\n      headers['Set-Cookie'] = cookieMod.serialize(self.cookie, id,\n        {\n          path: self.cookiePath,\n          httpOnly: self.cookiePath ? self.cookieHttpOnly : false\n        });\n    });\n  }\n\n  transport.onRequest(req);\n\n  this.clients[id] = socket;\n  this.clientsCount++;\n\n  socket.once('close', function () {\n    delete self.clients[id];\n    self.clientsCount--;\n  });\n\n  this.emit('connection', socket);\n};\n\n/**\n * Handles an Engine.IO HTTP Upgrade.\n *\n * @api public\n */\n\nServer.prototype.handleUpgrade = function (req, socket, upgradeHead) {\n  this.prepare(req);\n\n  var self = this;\n  this.verify(req, true, function (err, success) {\n    if (!success) {\n      abortConnection(socket, err);\n      return;\n    }\n\n    var head = new Buffer(upgradeHead.length);\n    upgradeHead.copy(head);\n    upgradeHead = null;\n\n    // delegate to ws\n    self.ws.handleUpgrade(req, socket, head, function (conn) {\n      self.onWebSocket(req, conn);\n    });\n  });\n};\n\n/**\n * Called upon a ws.io connection.\n *\n * @param {ws.Socket} websocket\n * @api private\n */\n\nServer.prototype.onWebSocket = function (req, socket) {\n  socket.on('error', onUpgradeError);\n\n  if (!transports[req._query.transport].prototype.handlesUpgrades) {\n    debug('transport doesnt handle upgraded requests');\n    socket.close();\n    return;\n  }\n\n  // get client id\n  var id = req._query.sid;\n\n  // keep a reference to the ws.Socket\n  req.websocket = socket;\n\n  if (id) {\n    var client = this.clients[id];\n    if (!client) {\n      debug('upgrade attempt for closed client');\n      socket.close();\n    } else if (client.upgrading) {\n      debug('transport has already been trying to upgrade');\n      socket.close();\n    } else if (client.upgraded) {\n      debug('transport had already been upgraded');\n      socket.close();\n    } else {\n      debug('upgrading existing transport');\n\n      // transport error handling takes over\n      socket.removeListener('error', onUpgradeError);\n\n      var transport = new transports[req._query.transport](req);\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n      transport.perMessageDeflate = this.perMessageDeflate;\n      client.maybeUpgrade(transport);\n    }\n  } else {\n    // transport error handling takes over\n    socket.removeListener('error', onUpgradeError);\n\n    this.handshake(req._query.transport, req);\n  }\n\n  function onUpgradeError () {\n    debug('websocket error before upgrade');\n    // socket.close() not needed\n  }\n};\n\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @api public\n */\n\nServer.prototype.attach = function (server, options) {\n  var self = this;\n  options = options || {};\n  var path = (options.path || '/engine.io').replace(/\\/$/, '');\n\n  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n  // normalize path\n  path += '/';\n\n  function check (req) {\n    return path === req.url.substr(0, path.length);\n  }\n\n  // cache and clean up listeners\n  var listeners = server.listeners('request').slice(0);\n  server.removeAllListeners('request');\n  server.on('close', self.close.bind(self));\n\n  // add request handler\n  server.on('request', function (req, res) {\n    if (check(req)) {\n      debug('intercepting request for path \"%s\"', path);\n      self.handleRequest(req, res);\n    } else {\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].call(server, req, res);\n      }\n    }\n  });\n\n  if (~self.transports.indexOf('websocket')) {\n    server.on('upgrade', function (req, socket, head) {\n      if (check(req)) {\n        self.handleUpgrade(req, socket, head);\n      } else if (false !== options.destroyUpgrade) {\n        // default node behavior is to disconnect when no handlers\n        // but by adding a handler, we prevent that\n        // and if no eio thing handles the upgrade\n        // then the socket needs to die!\n        setTimeout(function () {\n          if (socket.writable && socket.bytesWritten <= 0) {\n            return socket.end();\n          }\n        }, destroyUpgradeTimeout);\n      }\n    });\n  }\n};\n\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\nfunction abortConnection (socket, code) {\n  if (socket.writable) {\n    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : (code || '');\n    var length = Buffer.byteLength(message);\n    socket.write(\n      'HTTP/1.1 400 Bad Request\\r\\n' +\n      'Connection: close\\r\\n' +\n      'Content-type: text/html\\r\\n' +\n      'Content-Length: ' + length + '\\r\\n' +\n      '\\r\\n' +\n      message\n    );\n  }\n  socket.destroy();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}